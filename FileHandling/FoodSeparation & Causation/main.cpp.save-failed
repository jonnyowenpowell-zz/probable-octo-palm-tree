#include <iostream>
#include <string>
#include <fstream>
#include <stdexcept>
#include <vector>
#include <algorithm>

using namespace std;

static const string dataFileName= "./../food-enforcement.json";
static const string foodTypesFileName= "./Food Types.txt";
static const string outFileName= "./FoodTypeVSCause.txt";
static const string outFileNameSub= "./FoodTypeVSCause.txt";

static const string recallReasonStr="      \"reason_for_recall\": \"";
static const string productDescStr="      \"product_description\": \"";

static const string reasons[] ={"Undeclared Allergens","Mould/Spoiled","Salmonella","Machine Fragments","Other Contamination","Unknown"};
static const string alergens[] = {"almond","walnut","pecan","cashew","pistachio","peanut","nut","soy","egg","wheat","dye","fish","shellfish", "milk","dairy"};

static const string alergenKeyWords[] ={"undeclared","allergens"};
static const string mouldKeyWords[] ={"mould","spoil"};
static const string salmonellaKeyWords[] ={"undeclared","allergens"};
static const string machineKeyWords[] ={"undeclared","allergens"};
static const string otherCOntaminationWords[] ={"undeclared","allergens"};

//function declaration
void cleanWord(string* word);
bool isRecallReasonStr(string* str);
bool isUndeclaredAlergen(string* str);



struct RecallInfo{

    RecallInfo(string p){
        product=p;
        for(int i=0; i<sizeof(reasons)/sizeof(reasons[0]);++i){
            causes.push_back(reasons[i]);
            causeCount.push_back(0);
        }
        subCause.push_back(reasons[5]);
        subCount.push_back(0);
    }
    string product;
    vector<string> causes;
    vector<string> subCause;
    vector<int> causeCount;
    vector<int> subCount;
};

int main()
{
    ifstream dataFile(dataFileName);
    ifstream typeFile(foodTypesFileName);

    if(!dataFile.is_open() ){
        throw runtime_error("Error opening dataFile");
    }else if(!typeFile.is_open()){
        throw runtime_error("Error opening typeFile");
    }

    vector<vector<RecallInfo>> foodTypes;
    string line;
    //read in all food types
    while(getline(typeFile, line)){
        if(line.substr(0,2) =="//"){
            //do nothing
        }else{
            vector<RecallInfo> vec;
            int ind =0;
            for(int i=0; i<line.length(); ++i){
                if(line.at(i)==','){
                    string temp=line.substr(ind,i-ind);
                    vec.push_back(RecallInfo(temp));
                    ind=++i;
                }
            }
            foodTypes.push_back(vec);
        }
    }
    typeFile.close();
    vector<RecallInfo> vec;
    vec.push_back(reasons[5]);
    foodTypes.push_back(vec);

    //print out all food types
    for(unsigned i =0; i<foodTypes.size(); ++i){
        for(unsigned j=0; j<foodTypes.at(i).size(); ++j){
            cout << foodTypes.at(i).at(j).product <<endl;
        }
    }
    cout << endl << endl;

    //reason for recall
    string reason;

    //sub reason gives a more detailed reason for recall if nessisary, e.g. Reason=Undeclared allergen, subreason=milk
    string subreason;
    while(getline(dataFile, line)){

        if(isReasonRecallStr(&line)){
            cleanWord(&line);
            if(isMainReason(&line)){
                subreason = findUndeclaredSubReason(line);
            }else if(line.find("mould") !=string::npos || line.find("spoil") !=string::npos){
                reason = reasons[1];
                subreason = reasons[1];
            }else if(line.find("salmonella") !=string::npos ||line.find("listeria") !=string::npos ||line.find("monocytogenes") !=string::npos ||line.find("coli") !=string::npos){
                reason = reasons[2];
                subreason = reasons[2];
            }else if(line.find("glass") !=string::npos || line.find("metal") !=string::npos || line.find("cloth") !=string::npos ||line.find("piece") !=string::npos || line.find("wire") !=string::npos ||line.find("production equipment") !=string::npos ||line.find("fragment") !=string::npos || line.find("glass chip") !=string::npos){
                reason =  reasons[3];
                if(line.find("metal") !=string::npos ||line.find("wire") !=string::npos){
                    subreason = "Metal";
                }else if( line.find("glass") !=string::npos){
                    subreason = "Glass";
                }else if( line.find("cloth") !=string::npos){
                    subreason = "Cloth";
                }else{
                    subreason = reasons[5];
                }
            }else if(line.find("contaminat") !=string::npos ){
                reason = reasons[4];
                subreason = reasons[4];
            }else{
                reason = reasons[5];
                subreason = reasons[5];
            }
        }else if(line.substr(0,productDescStr.length())==productDescStr){
            cleanWord(&line);
            bool added = false;
            //find food type
            for(int i=0; i<foodTypes.size(); ++i){
                for(int j=0; j<foodTypes.at(i).size(); ++j){
                    //ri = correct food
                    RecallInfo* ri =&foodTypes.at(i).at(j);
                    int ind=line.find(ri->product);
                    if(ind !=string::npos){
                        for(int k=0; k<ri->causes.size(); ++k){
                            cout << ".";
                            if(ri->causes.at(k) ==reason){
                                ++(ri->causeCount.at(k));
                                for(int l=0; l<ri->subCause.size(); ++l){
                                    cout << ".";
                                    if(ri->subCause.at(l) == subreason){
                                        ++(ri->subCount.at(l));
                                        added = true;
                                        break;
                                    }
                                }
                                if(!added){
                                    ri->subCause.push_back(subreason);
                                    ri->subCount.push_back(1);
                                }
                                added=true;
                                cout << endl << ri->product << "," << reason << "," << subreason<<endl;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
                                 cout << "STUCK YOYOYOYOOY";

    dataFile.close();

    ofstream outputFile(outFileName);
    ofstream outputFileSubCause(outFileNameSub);
    int overallTotal[sizeof(reasons)/sizeof(reasons[0])];
    for(int i=0; i<sizeof(overallTotal)/sizeof(overallTotal[0]); ++i){
        overallTotal[i] =0;
    }
    for(int i=0; i<foodTypes.size(); ++i){
        for(int j=0; j<foodTypes.at(i).size(); ++j){
            RecallInfo* ri = &foodTypes.at(i).at(j);
            outputFile << ri->product << ",";
            outputFileSubCause << ri->product << ",";
            for(int k=0; k<ri->causes.size(); ++k){
                outputFile << ri->causes.at(k)<<"," << ri->causeCount.at(k) << ",";
                cout << ri->causes.at(k)<<"," << ri->causeCount.at(k) << ",";
                overallTotal[k] += ri->causeCount.at(k);
            }
            for(int k=0; k<ri->subCause.size(); ++k){
                outputFileSubCause << ri->subCause.at(k)<<"," << ri->subCount.at(k) << ",";
            }
            outputFile << "\n";
            outputFileSubCause << "\n";
        }
    }
    outputFile.close();
    outputFileSubCause.close();
    ofstream overallTotalFile("./Generalised totals.txt");
    for(int i=0; i<sizeof(reasons)/sizeof(reasons[0]); ++i){
        overallTotalFile << reasons[i] << "," << overallTotal[i] << "\n";
    }
    overallTotalFile.close();

    cout << "END" << endl;
    return 0;
}

bool isVariableStr(string* line, string* variableName ){
    return ( (line->substr(0,variableName->length()))==variableName);
}

bool isRecallReason(string* str){
    return isVariableStr(str, &recallReasonStr);
}

bool isProductDesc(string* str){
    return isVariableStr(str, &productDescStr);
}

bool isMainReason(string* line, string[]* mainReasons, int reasonLength){
    for(unsigned i=0; i<reasonLength; ++i){
        if(line->find((*mainReasons)[i]) != string::npos){
            return true;
        }
    }
}

bool isUndeclaredAlergen(string* str){
    return (str->find("undeclared") !=string::npos || str->find("allergen") !=string::npos);
}

string findUndeclaredAlergen(string* str){

    reason = reasons[0];
    vector<int> inds;
    //look up the start and end positions of "undeclared" and "alergen" (and any other added later)
    for(unsigned i=0; i<alergenKeyWords.size(); ++i){
        if(str->find(alergenKeyWords.at(i)) !=string::npos){
            inds.push_back(str->find(alergenKeyWords.at(i)));
            inds.push_back( (str->find(alergenKeyWords.at(i))) + alergenKeyWords.at(i).length());
        }
    }
    int mi=line.length();
    int ma=0;
    for(unsigned i=0; i<inds.size(); ++i ){
        if(ind[i]<mi){
            mi = ind[i];
        }else if(ind[i]>ma){
            ma = ind[i];
        }
    }

    string undeclaredAlergen="";
    bool found=false;
    //while not found slowly increment the length of the string
    while(!found){
        sub = line.substr(mi, ma-mi);
        mi-=5;
        ma+=5;
        if(mi<0){
            mi=0;
        }
        if(ma>line.length()-1){
            ma=line.length()-1;
        }
        for(int i=0; i<(sizeof(alergens)/sizeof(alergens[0])); ++i){
            if(sub.find(alergens[i]) !=string::npos){
                undeclaredAlergen = alergens[i];
                found =true;
            }
        }
        //if the string being looked at spans the entire line, and we haven't found the alergen, set alergen to unknown
        if(mi==0 && ma==(line.length()-1) && undeclaredAlergen.empty()){
            undeclaredAlergen = reasons[5];
            found=true;
        }
    }
    return undeclaredAlergen;
}

bool isUndeclaredAlergen(string* str){
    return line.find("mould") !=string::npos || line.find("spoil") !=string::npos
}

bool co


void cleanWord(string* word){
    for(string::iterator i = word->begin(); i != word->end(); i++)
    {
        if(!isalpha(word->at(i - word->begin())) && !(word->at(i - word->begin())==' '))
        {
            word->erase(i);
            --i;
        }
    }
    transform(word->begin(), word->end(), word->begin(), ::tolower);
}

